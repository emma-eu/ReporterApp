"use strict";(self.webpackChunkfeedback_map=self.webpackChunkfeedback_map||[]).push([[1438,79057,95393],{1438:(e,t,n)=>{n.d(t,{O7:()=>P,Hr:()=>b,el:()=>A,mT:()=>k,XX:()=>x});var r=n(86560),i=n(50076),s=n(76460),o=n(65215),c=n(23701),a=n(73548),l=n(80963),u=n(45417),f=n(3825),p=n(19902),h=n(54994);var d=n(90534),g=n(71838);const y=()=>s.A.getLogger("esri.geometry.support.normalizeUtils");function m(e){return"polygon"===e[0].type}function M(e){return"polyline"===e[0].type}function S(e){const t=[];let n=0,r=0;for(let i=0;i<e.length;i++){const s=e[i];let o=null;for(let e=0;e<s.length;e++)o=s[e],t.push(o),0===e?(n=o[0],r=n):(n=Math.min(n,o[0]),r=Math.max(r,o[0]));o&&t.push([(n+r)/2,0])}return t}function x(e,t){if(!(e instanceof c.A||e instanceof o.A)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw y().error(e),new i.A(e)}const n=(0,a.r8)(e),r=[];for(const i of n){const e=[];r.push(e),e.push([i[0][0],i[0][1]]);for(let n=0;n<i.length-1;n++){const r=i[n][0],s=i[n][1],o=i[n+1][0],c=i[n+1][1],a=Math.sqrt((o-r)*(o-r)+(c-s)*(c-s)),l=(c-s)/a,u=(o-r)/a,f=a/t;if(f>1){for(let c=1;c<=f-1;c++){const n=c*t,i=u*n+r,o=l*n+s;e.push([i,o])}const n=(a+Math.floor(f-1)*t)/2,i=u*n+r,o=l*n+s;e.push([i,o])}e.push([o,c])}}return function(e){return"polygon"===e.type}(e)?new o.A({rings:r,spatialReference:e.spatialReference}):new c.A({paths:r,spatialReference:e.spatialReference})}function w(e,t,n){if(t){const t=x(e,1e6);e=(0,u.ci)(t,!0)}return n&&(e=(0,a.kS)(e,n)),e}function v(e,t,n){if(Array.isArray(e)){const r=e[0];if(r>t){const n=(0,a.kd)(r,t);e[0]=r+n*(-2*t)}else if(r<n){const t=(0,a.kd)(r,n);e[0]=r+t*(-2*n)}}else{const r=e.x;if(r>t){const n=(0,a.kd)(r,t);e=e.clone().offset(n*(-2*t),0)}else if(r<n){const t=(0,a.kd)(r,n);e=e.clone().offset(t*(-2*n),0)}}return e}function R(e,t){let n=-1;for(let r=0;r<t.cutIndexes.length;r++){const i=t.cutIndexes[r],s=t.geometries[r],o=(0,a.r8)(s);for(let e=0;e<o.length;e++){const t=o[e];t.some((n=>{if(n[0]<180)return!0;{let n=0;for(let e=0;e<t.length;e++){const r=t[e][0];n=r>n?r:n}n=Number(n.toFixed(9));const r=-360*(0,a.kd)(n,180);for(let i=0;i<t.length;i++){const t=s.getPoint(e,i);s.setPoint(e,i,t.clone().offset(r,0))}return!0}}))}if(i===n){if(m(e))for(const t of(0,a.r8)(s))e[i]=e[i].addRing(t);else if(M(e))for(const t of(0,a.r8)(s))e[i]=e[i].addPath(t)}else n=i,e[i]=s}return e}async function A(e,t,n){if(!Array.isArray(e))return A([e],t);t&&"string"!=typeof t&&y().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const i="string"==typeof t?t:t?.url??r.A.geometryServiceUrl;let s,m,M,S,x,b,P,k,X=0;const _=[],G=[];for(const r of e)if(null!=r)if(s||(s=r.spatialReference,m=(0,l.Vp)(s),M=s.isWebMercator,b=M?102100:4326,S=a.j7[b].maxX,x=a.j7[b].minX,P=a.j7[b].plus180Line,k=a.j7[b].minus180Line),m)if("mesh"===r.type)G.push(r);else if("point"===r.type)G.push(v(r.clone(),S,x));else if("multipoint"===r.type){const e=r.clone();e.points=e.points.map((e=>v(e,S,x))),G.push(e)}else if("extent"===r.type){const e=r.clone()._normalize(!1,!1,m);G.push(e.rings?new o.A(e):e)}else if(r.extent){const e=r.extent,t=(0,a.kd)(e.xmin,x)*(2*S);let n=0===t?r.clone():(0,a.kS)(r.clone(),t);e.offset(t,0);let{xmin:i,xmax:s}=e;i=Number(i.toFixed(9)),s=Number(s.toFixed(9)),e.intersects(P)&&s!==S?(X=s>X?s:X,n=w(n,M),_.push(n),G.push("cut")):e.intersects(k)&&i!==x?(X=s*(2*S)>X?s*(2*S):X,n=w(n,M,360),_.push(n),G.push("cut")):G.push(n)}else G.push(r.clone());else G.push(r);else G.push(r);let N=(0,a.kd)(X,S),O=-90;const L=N,j=new c.A;for(;N>0;){const e=360*N-180;j.addPath([[e,O],[e,-1*O]]),O*=-1,N--}if(_.length>0&&L>0){const t=R(_,await async function(e,t,n,r){const i=(0,h.Dl)(e),s=t[0].spatialReference,o={...r,responseType:"json",query:{...i.query,f:"json",sr:(0,l.YX)(s),target:JSON.stringify({geometryType:(0,p.$B)(t[0]),geometries:t}),cutter:JSON.stringify(n)}},c=await(0,f.A)(i.path+"/cut",o),{cutIndexes:a,geometries:u=[]}=c.data;return{cutIndexes:a,geometries:u.map((e=>{const t=(0,p.rS)(e);return t.spatialReference=s,t}))}}(i,_,j,n)),r=[],s=[];for(let n=0;n<G.length;n++){const i=G[n];if("cut"!==i)s.push(i);else{const i=t.shift(),o=e[n];null!=o&&"polygon"===o.type&&o.rings&&o.rings.length>1&&i.rings.length>=o.rings.length?(r.push(i),s.push("simplify")):s.push(M?(0,u.Gh)(i):i)}}if(!r.length)return s;const o=await async function(e,t,n){const r="string"==typeof e?(0,d.An)(e):e,i=t[0].spatialReference,s=(0,p.$B)(t[0]),o={...n,query:{...r.query,f:"json",sr:(0,l.YX)(i),geometries:JSON.stringify((0,g.X)(t))}},{data:c}=await(0,f.A)(r.path+"/simplify",o);return(0,g.V)(c.geometries,s,i)}(i,r,n),c=[];for(let e=0;e<s.length;e++){const t=s[e];"simplify"!==t?c.push(t):c.push(M?(0,u.Gh)(o.shift()):o.shift())}return c}const I=[];for(let r=0;r<G.length;r++){const e=G[r];if("cut"!==e)I.push(e);else{const e=_.shift();I.push(!0===M?(0,u.Gh)(e):e)}}return I}function b(e){if(!e)return null;const t=e.extent;if(!t)return null;const n=e.spatialReference&&(0,l.Vp)(e.spatialReference);if(!n)return t;const[r,i]=n.valid,s=2*i,{width:o}=t;let c,{xmin:a,xmax:u}=t;if([a,u]=[u,a],"extent"===e.type||0===o||o<=i||o>s||a<r||u>i)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;c=S(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;c=S(e.paths);break;case"multipoint":c=e.points}const f=t.clone();for(let l=0;l<c.length;l++){let e=c[l][0];e<0?(e+=i,u=Math.max(e,u)):(e-=i,a=Math.min(e,a))}return f.xmin=a,f.xmax=u,f.width<o?(f.xmin-=i,f.xmax-=i,f):t}function P(e,t,n){const r=(0,l.Vp)(n);if(null==r)return e;const[i,s]=r.valid,o=2*s;let c=0,a=0;t>s?c=Math.ceil(Math.abs(t-s)/o):t<i&&(c=-Math.ceil(Math.abs(t-i)/o)),e>s?a=Math.ceil(Math.abs(e-s)/o):e<i&&(a=-Math.ceil(Math.abs(e-i)/o));let u=e+(c-a)*o;const f=u-t;return f>s?u-=o:f<i&&(u+=o),u}function k(e,t){const n=(0,l.Vp)(t);if(n){const[t,r]=n.valid,i=r-t;if(e<t)for(;e<t;)e+=i;if(e>r)for(;e>r;)e-=i}return e}},54994:(e,t,n)=>{n.d(t,{Dl:()=>o,jV:()=>s,lF:()=>c});n(86560),n(55171);var r=n(53084),i=n(90534);n(90924);function s(e,t){return t?{...t,query:{...e??{},...t.query}}:{query:e}}function o(e){return"string"==typeof e?(0,i.An)(e):(0,r.o8)(e)}function c(e,t,n){const r={};for(const i in e){if("declaredClass"===i)continue;const s=e[i];if(null!=s&&"function"!=typeof s)if(Array.isArray(s))r[i]=s.map((e=>c(e)));else if("object"==typeof s)if(s.toJSON){const e=s.toJSON(n?.[i]);r[i]=t?e:JSON.stringify(e)}else r[i]=t?s:JSON.stringify(s);else r[i]=s}return r}},58272:(e,t,n)=>{n.d(t,{X:()=>r,b:()=>i});const r=50,i=5},68002:(e,t,n)=>{n.d(t,{X_:()=>o,i1:()=>c,oW:()=>l,zx:()=>a});var r=n(15941),i=n(31633);const s=96;function o(e,t){const n=t||e.extent,r=e.width,o=(0,i.GA)(n?.spatialReference);return n&&r?n.width/r*o*i.dy*s:0}function c(e,t){return e/((0,i.GA)(t)*i.dy*s)}function a(e,t,n){return function(e,t){return 0===t||(0,r.Sp)(e,t)||e<t}(e,t)&&function(e,t){return 0===t||(0,r.Sp)(e,t)||e>t}(e,n)}function l(e,t){return(0,r.Sp)(e,t)?0:(e||Number.POSITIVE_INFINITY)>(t||Number.POSITIVE_INFINITY)?1:-1}},71838:(e,t,n)=>{n.d(t,{V:()=>s,X:()=>i});var r=n(19902);function i(e){return{geometryType:(0,r.$B)(e[0]),geometries:e.map((e=>e.toJSON()))}}function s(e,t,n){const i=(0,r.xD)(t);return e.map((e=>{const t=i.fromJSON(e);return t.spatialReference=n,t}))}},73548:(e,t,n)=>{n.d(t,{j7:()=>o,kS:()=>a,kd:()=>c,r8:()=>l});var r=n(23701),i=n(13312),s=n(19902);const o={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new r.A({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:i.A.WebMercator}),minus180Line:new r.A({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:i.A.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new r.A({paths:[[[180,-180],[180,180]]],spatialReference:i.A.WGS84}),minus180Line:new r.A({paths:[[[-180,-180],[-180,180]]],spatialReference:i.A.WGS84})}};function c(e,t){return Math.ceil((e-t)/(2*t))}function a(e,t){const n=l(e);for(const r of n)for(const e of r)e[0]+=t;return e}function l(e){return(0,s.Bi)(e)?e.rings:e.paths}},86524:(e,t,n)=>{n.d(t,{Ge:()=>p,WT:()=>d,XV:()=>h});var r=n(31633),i=n(19247),s=n(23701),o=n(13312),c=n(7137),a=n(1438),l=n(80963),u=n(45417),f=n(58272);function p(e,t,n){const r=1===e?10:e;return r**(n?Math.round(function(e,t){return Math.log(e)/Math.log(t)}(f.X/t,r)):0)}function h(e){const{isGeographic:t,isWebMercator:n}=e;return!t&&!n}function d(e,t,n){const f="number"==typeof e?null:e,p=n??f?.spatialReference;if(null==p||!(0,l.fn)(p)||h(p))return(0,r.GA)(p);let d=f?.x??e,g=f?.y??t;const y=1/Math.sqrt(2);let m=d+y,M=g+y;const{isWebMercator:S,isGeographic:x}=p;let w=x&&!(0,c.TT)(p)?o.A.WGS84:p;if(S){let e=new i.A({x:d,y:g,spatialReference:p});(0,u.ci)(e,!0,e),d=e.x,g=e.y,e=new i.A({x:m,y:M,spatialReference:p}),(0,u.ci)(e,!0,e),m=e.x,M=e.y,w=o.A.WGS84}const v=new s.A({paths:[[[d,g],[m,M]]],spatialReference:w}),R=(0,a.XX)(v,10);let A;try{[A]=(0,c.l1)([R],"meters")}catch{return(0,r.GA)(p)}return A}},95393:(e,t,n)=>{n.d(t,{GridSnappingEngine:()=>x});var r=n(35143),i=n(91967),s=n(76460),o=n(15941),c=n(31633),a=n(46053),l=(n(81806),n(47249),n(85842)),u=n(20664),f=n(9624),p=n(1438),h=n(68002),d=n(58272),g=n(86524),y=n(23862),m=n(70330),M=n(90836),S=n(45633);let x=class extends i.A{constructor(e){super(e),this.options=null}destroy(){this._set("options",null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:(0,o.kU)(this.view.rotation??0)}get gridRotation(){return(0,o.kU)(this.grid?.rotation??0)}get gridCenter(){const{spatialReference:e,grid:t}=this;if(!t||!e||!(0,f.isLoadedOrLoadFor)(t.center.spatialReference,e))return null;try{const n=(0,f.project)(t.center,e),r=e.isWrappable&&null!=this.view?.center?(0,p.O7)(n.x,this.view.center.x,e):n.x;return(0,y.vt)(r,n.y,n.z)}catch(n){return s.A.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.",n),null}}get offsetScaleFactor(){const{pixelsPerStride:e,grid:t}=this;if(!t||!e)return 1;const{majorLineInterval:n,dynamicScaling:r}=t;return n<1?null:(0,g.Ge)(n,e,r)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){const{grid:e}=this;return e?(0,c.oU)(e.spacing,e.units,"meters"):null}get viewMetersPerPixel(){const{viewMetersPerSRUnit:e}=this;return null==e?null:e*(0,h.i1)(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){const{spatialReference:e}=this.view;return this.gridCenter?(0,g.WT)(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){const{gridMetersPerStride:e,viewMetersPerPixel:t}=this;return t&&e?e/t:null}get updating(){return null!=this.grid&&null!=this.spatialReference&&null==this.viewMetersPerSRUnit}async fetchCandidates(e,t,n){const{options:r,view:i}=this;if(!r?.effectiveGridEnabled||!i.grid||n.feature?.attributes&&m.io in n.feature.attributes)return[];const s=n.coordinateHelper.arrayToPoint(e),o=r.distance*("touch"===n.pointer?r.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(s,o)}fetchCandidatesSync(e,t){const n=[],{grid:r,effectiveViewRotation:i,gridRotation:s,gridCenter:o,viewMetersPerPixel:c,viewMetersPerSRUnit:a,offsetScaleFactor:l,spatialReference:u,gridMetersPerStride:p,pixelsPerStride:h}=this;if(!(r&&c&&a&&o&&u&&l&&p&&h))return n;if(!r.dynamicScaling&&h<d.b)return n;if(!(0,f.isLoadedOrLoadFor)(e.spatialReference,u))return n;const g=(0,f.project)(e,u),m=(0,y.vt)(g.x,g.y,g.z),x=w(m,-s,o,-i),b=p/a*l,P=v(x,b,o),{shouldSnapX:k,shouldSnapY:X}=R(P,x,t,c,a);if(!k&&!X)return[];const _=(0,y.vt)((k?P:x)[0],(X?P:x)[1]),G=w(_,s,o,i),N=w(P,s,o,i);if(X){const e=A(P,x,b,"y"),t=w(e,s,o,i);n.push(new S.o({lineStart:N,lineEnd:t,targetPoint:G,isDraped:!1}))}if(k){const e=A(P,x,b,"x"),t=w(e,s,o,i);n.push(new S.o({lineStart:N,lineEnd:t,targetPoint:G,isDraped:!1}))}return k&&X&&n.push(new M.N(G,n[0],n[1],!1)),n}};(0,r._)([(0,a.MZ)({constructOnly:!0})],x.prototype,"view",void 0),(0,r._)([(0,a.MZ)()],x.prototype,"options",void 0),(0,r._)([(0,a.MZ)()],x.prototype,"grid",null),(0,r._)([(0,a.MZ)()],x.prototype,"effectiveViewRotation",null),(0,r._)([(0,a.MZ)()],x.prototype,"gridRotation",null),(0,r._)([(0,a.MZ)()],x.prototype,"gridCenter",null),(0,r._)([(0,a.MZ)()],x.prototype,"offsetScaleFactor",null),(0,r._)([(0,a.MZ)()],x.prototype,"spatialReference",null),(0,r._)([(0,a.MZ)()],x.prototype,"gridMetersPerStride",null),(0,r._)([(0,a.MZ)()],x.prototype,"viewMetersPerPixel",null),(0,r._)([(0,a.MZ)()],x.prototype,"viewMetersPerSRUnit",null),(0,r._)([(0,a.MZ)()],x.prototype,"pixelsPerStride",null),(0,r._)([(0,a.MZ)()],x.prototype,"updating",null),x=(0,r._)([(0,l.$)("esri.views.interactive.snapping.GridSnappingEngine")],x);const w=(e,t,n,r)=>{const i=(0,y.Hh)(e[0],e[1],e[2]);return(0,u.L)(i,(0,u.L)(i,i,n,t),n,r)},v=(e,t,n)=>{const r=(e[0]-n[0])/t,i=(e[1]-n[1])/t,s=Math.trunc(r),o=Math.trunc(i),c=Math.round(r%1),a=Math.round(i%1),l=n[0]+(s+c)*t,u=n[1]+(o+a)*t;return(0,y.vt)(l,u)},R=(e,t,n,r,i)=>{if(r<=0)return{shouldSnapX:!1,shouldSnapY:!1};const s=(e[0]-t[0])/r,o=(e[1]-t[1])/r;return{shouldSnapX:Math.abs(s*i)<n,shouldSnapY:Math.abs(o*i)<n}},A=(e,t,n,r)=>{if("y"===r){const r=t[0]>e[0]?1:-1;return(0,y.vt)(e[0]+n*r,e[1])}const i=t[1]>e[1]?1:-1;return(0,y.vt)(e[0],e[1]+n*i)}}}]);
//# sourceMappingURL=95393.fe6c5c84.chunk.js.map