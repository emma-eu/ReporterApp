"use strict";(self.webpackChunkfeedback_map=self.webpackChunkfeedback_map||[]).push([[7655],{10410:(e,t,i)=>{i.d(t,{A:()=>P});var n=i(35143),r=i(3825),s=i(50076),o=i(42553),l=i(76460),a=i(50346),c=i(34429),u=i(46053),h=i(40565),d=(i(81806),i(47249),i(85842)),m=i(76797),f=i(19247),p=i(13312),g=i(13096),y=i(95363),x=i(15359),_=i(22848),b=i(49653),v=i(88235),w=i(68347),I=i(12838),R=i(52297),S=i(37267),T=i(52494),k=i(59844),M=i(99846);let F=0,A=class extends o.A{constructor(){super(...arguments),this._tileFetchQueue=new c.QueueProcessor({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:v.A.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=(0,k.FT)(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}get rasterId(){return this.url||"rasterId-"+F++}set url(e){this._set("url",(0,g.Jf)(e,l.A.getLogger(this)))}async open(e){return this._openPromise??=(0,k.Hh)().then((()=>this._open(e))),this._openPromise}async fetchTile(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const r=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(e,t,i,r);return n={noClip:!0,...n},this.fetchPixels(s,r.size[0],r.size[1],n)}async identify(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e=(0,h.PZ)(f.A,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:n}=t,{rasterInfo:r}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:o}=r;let{transposedVariableName:l}=t;const a=null!=o&&s&&(null!=n||(0,w.DY)(i));a&&!l&&(l=null!=i&&i.length>0?i[0].variableName??void 0:o.variables[0].name,t={...t,transposedVariableName:l}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=r,{datumTransformation:d}=t;let p=(0,k._I)(e,c,d);if(!u.intersects(p))return{location:p,value:null};if(null!=r.transform){const e=r.transform.inverseTransform(p);if(!r.nativeExtent.intersects(e))return{location:e,value:null};p=e}let g=0;const y=null!=l&&null!=o&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(y)return e.identify(p,t);const{pixelSize:n}=r,s=3,o=n.x*s/2,l=n.y*s/2,a=new m.A({xmin:p.x-o,xmax:p.x+o,ymin:p.y-l,ymax:p.y+l,spatialReference:c}),u={interpolation:"nearest",multidimensionalDefinition:i,sliceId:t.sliceId},{pixelBlock:h}=await e.fetchPixels(a,s,s,u),{pixelBlock:d}=await this.fetchPixels(a,s,s,u);if(null==h)return{location:p,value:null};const f=Math.floor(s*s*.5),g=!h.mask||h.mask[f]?h.pixels.map((e=>e[f])):null;let x;return null!=d&&(x=!d.mask||d.mask[f]?d.pixels.map((e=>e[f])):void 0),{location:p,value:g,processedValue:x,pyramidLevel:0}}if(!y)if(t.srcResolution)g=(0,k.t$)(t.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(g=await this.computeBestPyramidLevelForLocation(e,t),null==g)return{location:p,value:null};const x=this.identifyPixelLocation(p,g,null,y);if(null===x)return{location:p,value:null};const{row:_,col:b,rowOffset:v,colOffset:R,blockWidth:S}=x,T=l??t.sliceId,M=(0,I.ph)(this.rasterId,T),F=`${g}/${_}/${b}`;let A=(0,I.gd)(M,null,F);null==A&&(A=this.fetchRawTile(g,_,b,t),(0,I.no)(M,null,F,A));const P=await A;if(!P?.pixels?.length)return{location:p,value:null};const C=v*S+R;return this._processIdentifyResult(P,{srcLocation:p,position:C,pyramidLevel:g,useTransposedTile:!!y,requestSomeSlices:a,identifyOptions:t})}async fetchPixels(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};e=(0,k.Ps)(e),n=this._getRequestOptionsWithSliceId(n);const{_hasNoneOrGCSShiftTransform:r}=this;if(n.requestRawData&&r)return this._fetchPixels(e,t,i,n);const s=(0,k.FT)(e.spatialReference),o=(0,k.OM)(e);if(null==s||0===o||1===o&&this._isGlobalWrappableSource&&r)return this._fetchPixels(e,t,i,n);if(o>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:a,xmax:c}=e,u=Math.round(s/(c-a)*t),h=u-Math.round((s/2-a)/(c-a)*t);let d=0;const f=[];for(let x=0;x<=o;x++){const r=new m.A({xmin:0===x?a:-s/2,xmax:x===o?c-s*x:s/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===x?u-h:x===o?t-d:u;d+=p,f.push(p);const g=n.disableWrapAround&&x>0?null:this._fetchPixels(r,p,i,n);l.push(g)}const p=(await Promise.all(l)).map((e=>e?.pixelBlock));let g=null;const y={width:t,height:i};return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},n)).pixelBlock:(0,T.z7)(p,y,{blockWidths:f}),{extent:e,srcExtent:(0,k._l)(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:g}}async fetchRawPixels(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t={x:Math.floor(t.x),y:Math.floor(t.y)};const r=await this._fetchRawTiles(e,t,i,n),{nativeExtent:s,nativePixelSize:o,storageInfo:l}=this.rasterInfo,a=2**e,c=o.x*a,u=o.y*a,h=new m.A({xmin:s.xmin+c*t.x,xmax:s.xmin+c*(t.x+i.width-1),ymin:s.ymax-u*(t.y+i.height-1),ymax:s.ymax-u*t.y,spatialReference:s.spatialReference});if(!r)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:d,mosaicSize:f}=r;if(1===d.length&&null!=d[0]&&d[0].width===i.width&&d[0].height===i.height)return{extent:h,srcExtent:h,pixelBlock:r.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,g=e>0?l.pyramidBlockHeight:l.blockHeight,y={x:t.x%p,y:t.y%g};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:f,destDimension:i,clipOffset:y,clipSize:i,coefs:null,sampleSpacing:null,interpolation:n.interpolation,alignmentInfo:null,blockWidths:null},n)).pixelBlock:(0,T.z7)(d,f,{clipOffset:y,clipSize:i}),{extent:h,srcExtent:h,pixelBlock:x}}fetchRawTile(e,t,i,n){throw new s.A("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return(0,k._l)(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?(0,S.D)(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const{customFetchParameters:n}=this.ioConfig,{range:s,query:o,headers:l}=t;i=i??t.retryCount??this.ioConfig.retryCount;const a=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return await(0,r.A)(e,{...t,query:{...o,...n},headers:{...l,...a}})}catch(c){if(i>0)return i--,this.request(e,t,i);throw c}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:(0,w.NG)(e,t)}getTileExtentFromTileInfo(e,t,i,n){const r=n.lodAt(e);return this.getTileExtent({x:r.resolution,y:r.resolution},t,i,n.origin,n.spatialReference,n.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:n}=this.rasterInfo,{pyramidResolutions:r}=e;if(!e.tileInfo){const s=[],o=e.maximumPyramidLevel||0;let l=(n.x+n.y)/2,a=1/.0254*96*l;for(let e=0;e<=o&&(s.unshift(new _.A({level:o-e,resolution:l,scale:a})),e!==o);e++)if(r){const t=(r[e].x+r[e].y)/2;a*=t/l,l=t}else l*=2,a*=2;const c=new f.A({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new v.A({origin:c,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:s}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:512,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:512,n=arguments.length>3?arguments[3]:void 0;const{width:r,height:s,nativeExtent:o,pixelSize:l,spatialReference:a}=e,c=new f.A({x:o.xmin,y:o.ymax,spatialReference:a});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(r,s))/Math.LN2-8)));const u=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[l],n);e.storageInfo=new b.A({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})}async computeBestPyramidLevelForLocation(e){return 0}computeBlockBoundary(e,t,i,n,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:2;if(1===r.length&&s>0){r=[...r];let{x:e,y:t}=r[0];for(let i=0;i<s;i++)e*=o,t*=o,r.push({x:e,y:t})}const l=[],{x:a,y:c}=n;for(let u=0;u<r.length;u++){const{x:n,y:s}=r[u];l.push({minCol:Math.floor((e.xmin-a+.1*n)/t/n),maxCol:Math.floor((e.xmax-a-.1*n)/t/n),minRow:Math.floor((c-e.ymax+.1*s)/i/s),maxRow:Math.floor((c-e.ymin-.1*s)/i/s)})}return l}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const r=n**e;return{x:t.x*r,y:t.y*r}}identifyPixelLocation(e,t,i,n){const{spatialReference:r,nativeExtent:s,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=o,u=n&&null!=c?c.tileSize[0]:o.blockWidth,h=n&&null!=c?c.tileSize[1]:o.blockHeight,d=(0,k._I)(e,r,i);if(!s.intersects(d))return null;if(t<0||t>l)return null;const m=this.getPyramidPixelSize(t),{x:f,y:p}=m,g=(a.y-d.y)/p/h,y=(d.x-a.x)/f/u,x=Math.min(h-1,Math.floor((g-Math.floor(g))*h)),_=Math.min(u-1,Math.floor((y-Math.floor(y))*u));return{pyramidLevel:t,row:Math.floor(g),col:Math.floor(y),rowOffset:x,colOffset:_,blockWidth:u,srcLocation:d}}getTileExtent(e,t,i,n,r,s){const[o,l]=s,a=n.x+i*o*e.x,c=a+o*e.x,u=n.y-t*l*e.y,h=u-l*e.y;return new m.A({xmin:a,xmax:c,ymin:h,ymax:u,spatialReference:r})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<i||n.minRow>t||n.minCol>i}updateImageSpaceRasterInfo(e){const{pixelSize:t}=e,{width:i,height:n}=e,r=p.A.WebMercator;e.spatialReference=r,e.extent=e.nativeExtent=new m.A({xmin:-.5,ymax:.5,xmax:i-.5,ymin:.5-n,spatialReference:r}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new f.A({x:1,y:1,spatialReference:r});const{extent:s,storageInfo:o}=e;if(o){o.origin=new f.A({x:s.xmin,y:s.ymax,spatialReference:r});const{pyramidResolutions:i,tileInfo:n}=o;if(i&&i.forEach((e=>{e.x/=t.x,e.y/=t.y})),n){n.origin=o.origin;const t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;n.lods.forEach(((e,i)=>{e.resolution=t*2**i,e.scale=96*e.resolution/.0254}))}}}async _fetchPixels(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=(0,k.OM)(e);if(r>=2)return{extent:e,pixelBlock:null};const s=this._getSourceDataInfo(e,t,i,n),{pyramidLevel:o,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:u,ul:h}=s;if(0===c||0===u)return{extent:e,srcExtent:a,pixelBlock:null};const{rasterInfo:d}=this,m=d.transform,p="gcs-shift"===m?.type,g=null!=(0,k.FT)(e.spatialReference);!p&&g||(r=(0,k.OM)(s.srcExtent,p));const y=await this._fetchRawTiles(o,h,{width:c,height:u,wrapCount:r},n);if(!y)return{extent:e,srcExtent:a,pixelBlock:null};const x=d.storageInfo,_=o>0?x.pyramidBlockWidth:x.blockWidth,b=o>0?x.pyramidBlockHeight:x.blockHeight;let{x:v,y:w}=d.pixelSize;if(o>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=x;if(null!=e&&e[o-1])({x:v,y:w}=e[o-1]);else{const e=t**o;v*=e,w*=e}}const I=d.spatialReference,R=new f.A({x:v,y:w,spatialReference:I}),S=_===c&&b===u&&h.x%_==0&&h.y%b==0,F=new f.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),A=!e.spatialReference.equals(I),P=I.isGeographic?1e-9:1e-4,{datumTransformation:C}=n;if(!A&&S&&1===y.pixelBlocks.length&&_===t&&b===i&&function(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i}(l,F,P))return{extent:e,srcExtent:a,srcTilePixelSize:R,pixelBlock:y.pixelBlocks[0]};const J=g&&null!=(0,k.FT)(a.spatialReference)&&this._hasNoneOrGCSShiftTransform,D=n.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");D&&!this.rasterJobHandler&&await(0,k.Hh)();const z=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:F.toJSON(),datumTransformation:C,rasterTransform:m,hasWrapAround:r>0||J,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:D},n):(0,k.l0)({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:F,datumTransformation:C,rasterTransform:m,hasWrapAround:r>0||J,isAdaptive:!1,includeGCSGrid:D});let B;const H=!n.requestRawData,N={rows:z.spacing[0],cols:z.spacing[1]},E=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(o,y.extent.xmin):void 0,{pixelBlocks:O,mosaicSize:q,isPartiallyFilled:W}=y;let Z=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:O,srcMosaicSize:q,destDimension:H?{width:t,height:i}:null,coefs:H?z.coefficients:null,sampleSpacing:H?N:null,projectDirections:D,gcsGrid:D?z.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:n.interpolation,alignmentInfo:E,blockWidths:null},n);({pixelBlock:B,localNorthDirections:Z}=e)}else{const e=(0,T.z7)(O,q,{alignmentInfo:E});B=H?(0,T.$i)(e,{width:t,height:i},z.coefficients,N,n.interpolation):e,D&&z.gcsGrid&&(Z=(0,T.QF)({width:t,height:i},z.gcsGrid),B=(0,M.Y2)(B,this.rasterInfo.dataType,Z))}return n.requestRawData||D?{extent:e,srcExtent:a,srcTilePixelSize:R,pixelBlock:B,transformGrid:z,localNorthDirections:Z,isPartiallyFilled:W}:{extent:e,srcExtent:a,srcTilePixelSize:R,pixelBlock:B}}async _fetchRawTiles(e,t,i,n){const{origin:r,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:l}=this.getBlockWidthHeight(e);let{x:a,y:c}=t,{width:u,height:h,wrapCount:d}=i;const f=this._getRasterTileAlignmentInfo(e,0);n.buffer&&(a-=n.buffer.cols,c-=n.buffer.rows,u+=2*n.buffer.cols,h+=2*n.buffer.rows);let p=0,g=0,y=0;d&&null!=f&&(({worldColumnCountFromOrigin:g,originColumnOffset:y,rightPadding:p}=f),g*f.blockWidth-p>=a+u&&(p=0));const x=Math.floor(a/o),_=Math.floor(c/l),b=Math.floor((a+u+p-1)/o),v=Math.floor((c+h+p-1)/l),w=s[e];if(!w)return null;const{minRow:I,minCol:R,maxCol:S,maxRow:T}=w;if(0===d&&(v<I||b<R||_>T||x>S))return null;const k=new Array;let M=!1;const F=null==this.ioConfig.allowPartialFill?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let m=_;m<=v;m++)for(let t=x;t<=b;t++){let i=t;if(!n.disableWrapAround&&d&&null!=f&&g<=t&&(i=t-g-y),m>=I&&i>=R&&T>=m&&S>=i){const t=this._tileFetchQueue.push({pyramidLevel:e,row:m,col:i,options:n},{signal:n.signal});F?k.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{M=!0,e(null)}))}))):k.push(t)}else k.push(Promise.resolve(null))}if(0===k.length)return null;const A=await Promise.all(k),P={height:(v-_+1)*l,width:(b-x+1)*o},{spatialReference:C}=this.rasterInfo,J=this.getPyramidPixelSize(e),{x:D,y:z}=J;return{extent:new m.A({xmin:r.x+x*o*D,xmax:r.x+(b+1)*o*D,ymin:r.y-(v+1)*l*z,ymax:r.y-_*l*z,spatialReference:C}),pixelBlocks:A,mosaicSize:P,isPartiallyFilled:M}}_fetchRawTile(e,t,i,n){const r=this.rasterInfo.storageInfo.blockBoundary[e];if(!r)return Promise.resolve(null);const{minRow:s,minCol:o,maxCol:l,maxRow:c}=r;if(t<s||i<o||t>c||i>l)return Promise.resolve(null);const u=(0,I.ph)(this.rasterId,n.sliceId),h=`${e}/${t}/${i}`;let d=(0,I.gd)(u,n.registryId,h);if(null==d){const r=new AbortController;d=this.fetchRawTile(e,t,i,{...n,signal:r.signal}),(0,I.no)(u,n.registryId,h,d,r),d.catch((()=>(0,I.zo)(u,n.registryId,h)))}return n.signal&&(0,a.u7)(n,(()=>{(0,I.jX)(u,n.registryId,h)})),d}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if((2!==t||"vector-magdir"!==i)&&"vector-uv"!==i||2!==e?.length||!e[0]?.length)return null;const n=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[r,s]=e,o=[],l=[];for(let a=0;a<n;a++){const[e,t]=(0,M.Lu)([r[a],s[a]]);o.push(e),l.push(t)}return[o,l]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=(0,k.DO)(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const r={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};n.srcResolution&&(r.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,r));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:l,pyramidLevel:a}=r,c=o/t,u=l/i,h=a<s&&c*u>=16,d=a===s&&this._requireTooManySrcTiles(o,l,t,i);if(h||d||0===o||0===l){const o=new f.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=(0,k.Wo)(o,this.rasterInfo.spatialReference,e,r.datumTransformation);const d=!l||n.srcResolution&&l.x+l.y<n.srcResolution.x+n.srcResolution.y;if(h&&n.srcResolution&&d){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(s-a+3>=e){const t=2**e;l={x:n.srcResolution.x*t,y:n.srcResolution.y*t}}}l&&(r.srcResolution=l,this._updateSourceDataInfo(e,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,t,i)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(e,t,i,n){const{tileInfo:r}=this.rasterInfo.storageInfo,s=e/i,o=t/n;return Math.ceil(e/r.size[0])*Math.ceil(t/r.size[1])>=256*Math.max(1,(i+n)/1024)||s>8||o>8}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,n=i.spatialReference,{srcResolution:r,datumTransformation:s}=t,{pyramidLevel:o,pyramidResolution:l,excessiveReading:a}=(0,k.t$)(r,i,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||(0,k._l)(e,n,s);if(null==c)return;const u=i.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:h,y:d}=i.storageInfo.origin,m=Math.floor((c.xmin-h)/l.x+.1),f=Math.floor((d-c.ymax)/l.y+.1),p=Math.floor((c.xmax-h)/l.x-.1),g=Math.floor((d-c.ymin)/l.y-.1),y=c.width<.1*l.x?0:p-m+1,x=c.height<.1*l.y?0:g-f+1;t.pyramidLevel=o,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=x,t.ul={x:m,y:f}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:n,pyramidLevel:r,useTransposedTile:s}=t,o=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[n])return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!s){const t=e.pixels.map((e=>e[n])),s={location:i,value:t,pyramidLevel:r},o=this._computeMagDirValues(t.map((e=>[e])));return o?.length&&(s.magdirValue=o.map((e=>e[0]))),s}let a=e.pixels.map((e=>e.slice(n*o,n*o+o))),c=this._computeMagDirValues(a);const{requestSomeSlices:u,identifyOptions:h}=t;let d=(0,w.QW)(l,h.transposedVariableName);if(u){const e=(0,w.xx)(d,h.multidimensionalDefinition,h.timeExtent);a=a.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),d=e.map((e=>d[e]))}const m=e.noDataValues||this.rasterInfo.noDataValue,f={pixels:a,pixelType:e.pixelType};let p;return null!=m&&((0,R.Sp)(f,m),p=f.mask),{location:i,value:null,dataSeries:d.map(((e,t)=>{const i={value:0===p?.[t]?null:a.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new x.A({...e,isSlice:!0})))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i})),pyramidLevel:r}}};(0,n._)([(0,u.MZ)()],A.prototype,"_rasterTileAlignmentInfo",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"_tileFetchQueue",void 0),(0,n._)([(0,u.MZ)({readOnly:!0})],A.prototype,"_isGlobalWrappableSource",null),(0,n._)([(0,u.MZ)({readOnly:!0})],A.prototype,"_hasNoneOrGCSShiftTransform",null),(0,n._)([(0,u.MZ)()],A.prototype,"_openPromise",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"rasterJobHandler",null),(0,n._)([(0,u.MZ)({readOnly:!0})],A.prototype,"rasterId",null),(0,n._)([(0,u.MZ)(y.OZ)],A.prototype,"url",null),(0,n._)([(0,u.MZ)({type:String,json:{write:!0}})],A.prototype,"datasetName",void 0),(0,n._)([(0,u.MZ)({type:String,json:{write:!0}})],A.prototype,"datasetFormat",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"hasUniqueSourceStorageInfo",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"rasterInfo",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"ioConfig",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"sourceJSON",void 0),A=(0,n._)([(0,d.$)("esri.layers.support.rasterDatasets.BaseRaster")],A);const P=A},12838:(e,t,i)=>{i.d(t,{jX:()=>u,zo:()=>m,gd:()=>h,ph:()=>l,no:()=>d,kz:()=>a,ht:()=>c,yo:()=>p});var n=i(19247);var r=i(59844);const s=new Map,o=new class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:15e3,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){const i=e+"/"+t,n=this._cachedBlocks;if(n.has(i)){const e=n.get(i);return e.refCount--,e.refCount<=0&&(n.delete(i),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){const i=e+"/"+t,n=this._cachedBlocks;if(n.has(i)){const e=n.get(i);return e.ts=Date.now(),e.refCount++,n.delete(i),n.set(i,e),e.block}return null}putBlock(e,t,i,n){const r=this._cachedBlocks,s=e+"/"+t;if(r.has(s)){const e=r.get(s);e.ts=Date.now(),e.refCount++}else r.set(s,{block:i,ts:Date.now(),refCount:1,controller:n});this._trim(),this._updateTimer()}deleteBlock(e,t){const i=this._cachedBlocks,n=e+"/"+t;i.has(n)&&i.delete(n)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const e=this._cachedBlocks;this._timer=setInterval((()=>{const t=Array.from(e),i=Date.now();for(let n=0;n<t.length&&t[n][1].ts<=i-this._duration;n++)e.delete(t[n][0]);0===e.size&&this._clearTimer()}),this._interval)}_trim(){const e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;const t=Array.from(e);for(let i=0;i<t.length-this._size;i++)e.delete(t[i][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function l(e,t){return null==t?e:`${e}?sliceId=${t}`}function a(e,t){const i={extent:null,rasterInfo:t,cache:new Map},n=s.get(e);return n?(n.push(i),n.length-1):(s.set(e,[i]),0)}function c(e,t){const i=s.get(e);i&&(i[t]=null,i.some((e=>null!=e))||s.delete(e))}function u(e,t,i){const n=s.get(e);if(!n)return null==t?o.decreaseRefCount(e,i):0;if(null==t||null==n[t])return o.decreaseRefCount(e,i);const r=n[t]?.cache,l=r?.get(i);if(r&&l){if(l.refCount--,0===l.refCount){r.delete(i);for(let e=0;e<n.length;e++)n[e]?.cache.delete(i);l.controller&&l.controller.abort()}return l.refCount}return 0}function h(e,t,i){const n=s.get(e);if(!n)return null==t?o.getBlock(e,i):null;if(null==t||null==n[t]){for(let e=0;e<n.length;e++){const t=n[e]?.cache.get(i);if(t)return t.refCount++,t.block}return o.getBlock(e,i)}const r=n[t]?.cache.get(i);if(r)return r.refCount++,r.block;for(let s=0;s<n.length;s++){if(s===t||!n[s])continue;const e=n[s]?.cache,r=e?.get(i);if(e&&r)return r.refCount++,e.set(i,r),r.block}return null}function d(e,t,i,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const l=s.get(e);if(!l)return void(null==t&&o.putBlock(e,i,n,r));if(null==t||null==l[t])return void o.putBlock(e,i,n,r);const a={refCount:1,block:n,isResolved:!1,isRejected:!1,controller:r};n.then((()=>a.isResolved=!0)).catch((()=>a.isRejected=!0)),l[t]?.cache.set(i,a)}function m(e,t,i){const n=s.get(e);n?null!=t&&null!=n[t]?n[t]?.cache.delete(i):o.deleteBlock(e,i):null==t&&o.deleteBlock(e,i)}function f(e,t){const i=s.get(e);return i?i[t]??null:null}function p(e,t,i,s,o,l){let a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const c=f(e,t);if(!c)return;const u=c.extent,{cache:h,rasterInfo:d}=c;if(u&&u.xmin===i.xmin&&u.xmax===i.xmax&&u.ymin===i.ymin&&u.ymax===i.ymax)return;s=s??0;const m=i.clone().normalize(),{spatialReference:p,transform:g}=d,y=new Set;for(let f=0;f<m.length;f++){const e=m[f];if(e.xmax-e.xmin<=s||e.ymax-e.ymin<=s)continue;let t=(0,r._l)(e,p,a);null!=g&&(t=g.inverseTransform(t));const i=new n.A({x:s,y:s,spatialReference:e.spatialReference});if(null==o&&!(o=(0,r.Wo)(i,p,e,a)))return;const{pyramidLevel:c,pyramidResolution:u,excessiveReading:h}=(0,r.t$)(o,d,l||"closest");if(h)return;const{storageInfo:x}=d,{origin:_}=x,{x:b,y:v}=u,w=Math.max(0,Math.floor((t.xmin-_.x)/b)),I=Math.max(0,Math.floor((_.y-t.ymax)/v)),R=Math.ceil(t.width/b-.1),S=Math.ceil(t.height/v-.1),T=c>0?x.pyramidBlockWidth:x.blockWidth,k=c>0?x.pyramidBlockHeight:x.blockHeight,M=x.blockBoundary[c];if(!M)continue;const F=1,A=Math.max(M.minCol,Math.floor(w/T)-F),P=Math.max(M.minRow,Math.floor(I/k)-F),C=Math.min(M.maxCol,Math.floor((w+R-1)/T)+F),J=Math.min(M.maxRow,Math.floor((I+S-1)/k)+F);for(let n=P;n<=J;n++)for(let e=A;e<=C;e++)y.add(`${c}/${n}/${e}`)}h.forEach(((e,t)=>{if(!y.has(t)){const e=h.get(t);(null==e||e.isResolved||e.isRejected)&&h.delete(t)}})),c.extent={xmin:i.xmin,ymin:i.ymin,xmax:i.xmax,ymax:i.ymax}}},16175:(e,t,i)=>{i.d(t,{A:()=>f});var n=i(35143),r=i(50076),s=i(46053),o=(i(81806),i(76460),i(47249),i(85842)),l=i(65215),a=i(10410),c=i(61229),u=i(52494),h=i(59844),d=i(77725);let m=class extends a.A{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{rasters:r,rasterIds:s}=this.primaryRasters;let o=!1;const{interpolation:l}=n,a=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!n.requestRawData&&a&&(o=1===r.length&&!n.skipRasterFunction,n={...n,interpolation:"bilinear",requestRawData:o});const h=r.map((r=>r.fetchPixels(e,t,i,n))),d=await Promise.all(h),m=d.map((e=>e.pixelBlock)),f=o||n.requestRawData?d.map((e=>e.srcTilePixelSize)):null;if(n.skipRasterFunction||m.every((e=>null==e)))return d[0];const p=d.find((e=>null!=e.pixelBlock))?.extent??e;let g=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:m,primaryPixelSizes:f,primaryRasterIds:s}):this.rasterFunction.process({extent:p,primaryPixelBlocks:m,primaryPixelSizes:f,primaryRasterIds:s});const{transformGrid:y}=d[0];if(!o||null==g||null==y){const e=n.noClip?null:this.getClippingGeometry(p.spatialReference);return n.noClip||n.requestRawData||null==g||!e||(g=await(0,c.$Q)(g,p,e)),{...d[0],pixelBlock:g}}const x={rows:y.spacing[0],cols:y.spacing[1]};let _;_=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[g],srcMosaicSize:{width:g.width,height:g.height},destDimension:{width:t,height:i},coefs:y.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:l,alignmentInfo:void 0,blockWidths:null},n)).pixelBlock:(0,u.$i)(g,{width:t,height:i},y.coefficients,x,l);const b=n.noClip?null:this.getClippingGeometry(e.spatialReference);return n.noClip||n.requestRawData||null==_||null==b||(_=await(0,c.$Q)(_,e,b)),{extent:e,srcExtent:d[0].srcExtent,pixelBlock:_}}getClippingGeometry(e){const t=this._clippingGeometry.get("0");if(!e||!t)return t;const i=function(e){return String(e.wkid??e.wkt??e.wkt2)}(e);let n=this._clippingGeometry.get(i);return null!=n||(n=e.equals(t.spatialReference)?t:(0,h.uk)(t,e),this._clippingGeometry.set(i,n)),n}async _open(e){const{rasterFunction:t}=this;this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((e=>e.rasterJobHandler=this.rasterJobHandler)));const{rasters:i,rasterIds:n}=this.primaryRasters,s=i.map((t=>t.rasterInfo?void 0:t.open(e)));await Promise.all(s);const o=i.map((e=>{let{rasterInfo:t}=e;return t})),l=t.bind({rasterInfos:o,rasterIds:n});if(t.rawSourceRasterInfos=o,!l.success||0===o.length)throw new r.A("raster-function:open",`cannot bind the function: ${l.error??""}`);const a="Table"===t.functionName?t:t.functionArguments?.raster;"Table"===a?.functionName&&(t.rasterInfo.attributeTable=d.A.fromJSON(a.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=o[0];this.hasUniqueSourceStorageInfo=1===o.length||o.slice(1).every((e=>function(e,t){const{storageInfo:i,pixelSize:n,spatialReference:r,extent:s}=e,{storageInfo:o,pixelSize:l,spatialReference:a,extent:c}=t;return n.x===l.x&&n.y===l.y&&r.equals(a)&&s.equals(c)&&i.blockHeight===o.blockHeight&&i.blockWidth===o.blockWidth&&i.maximumPyramidLevel===o.maximumPyramidLevel}(e,c))),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const e=this.rasterFunction.getClippingGeometries()[0];let t=e?.clippingGeometry;if(t&&"inside"===e.clippingType){const{extent:e}=this.rasterInfo,{difference:n,densify:r}=await Promise.all([i.e(2612),i.e(3391)]).then(i.bind(i,63391));let s=r(l.A.fromExtent(e),2*(e.width+e.height)/40);s=(0,h.uk)(s,t.spatialReference),t=n(s,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};(0,n._)([(0,s.MZ)({type:String,json:{write:!0}})],m.prototype,"datasetFormat",void 0),(0,n._)([(0,s.MZ)()],m.prototype,"tileType",void 0),(0,n._)([(0,s.MZ)()],m.prototype,"rasterFunction",void 0),(0,n._)([(0,s.MZ)()],m.prototype,"primaryRasters",void 0),m=(0,n._)([(0,o.$)("esri.layers.support.rasterDatasets.FunctionRaster")],m);const f=m},24709:(e,t,i)=>{i.d(t,{o:()=>z});var n=i(35143),r=i(3825),s=i(50076),o=i(76460),l=i(46053),a=i(40565),c=(i(81806),i(47249),i(6409)),u=i(28379),h=i(85842),d=i(19247),m=i(13312),f=i(80963),p=i(13096),g=i(95363),y=i(15359),x=i(13023),_=i(58646),b=i(44038),v=i(42915),w=i(88235),I=i(16175),R=i(68347),S=i(61229),T=i(81633),k=i(59844),M=i(86866),F=i(99846),A=i(78937),P=i(20118),C=i(88205),J=i(46570),D=i(46533);const z=e=>{let t=class extends e{constructor(){super(...arguments),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===(arguments.length<=0?void 0:arguments[0])?.raster?.datasetFormat}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",(0,p.Jf)(e,o.A.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:t}=this;if(e){const i=t?.find((t=>{let{name:i}=t;return i===e}));return i?.renderer.clone()}return this.internalRenderer}set renderer(e){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,t,i){const n=t?.layerDefinition?.drawingInfo?.renderer;return(0,C.LF)(n,i)||void 0}async convertVectorFieldData(e,t){const{serviceRasterInfo:i}=this;if(null==e||!i)return null;const n=this._rasterJobHandler.instance,r=i.dataType;return n?n.convertVectorFieldData({pixelBlock:e,dataType:r},t):(0,F.FI)(e,r)}async computeStatisticsHistograms(e,t){await this.load(t),e=(0,a.PZ)(J.A,e).clone();const{serviceRasterInfo:i}=this;if(null==i)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:n}=e;if(null==n)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let r=n;const{spatialReference:o}=i;n.spatialReference.equals(o)||(await(0,k.Hh)(),r="extent"===n.type?(0,k._l)(n,o):(0,k.uk)(n,o));const l=e.pixelSize??new d.A({x:i.pixelSize.x,y:i.pixelSize.y,spatialReference:o}),{extent:c,width:u,height:h}=(0,S.b7)(i,r,l),m=await this.fetchPixels(c,u,h,{...t,interpolation:"nearest"});if(null==m.pixelBlock)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const f=await(0,S.$Q)(m.pixelBlock,c,r),p=this._rasterJobHandler.instance;return p?p.computeStatisticsHistograms({pixelBlock:f},t):(0,M.eH)(f)}async createFlowMesh(e,t){const i=this._rasterJobHandler.instance;return i?i.createFlowMesh(e,t):(0,D.CW)(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(null==t)return e;const i=(0,R.XU)({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:i}}async updateRasterFunction(){return this.loaded&&"imagery-tile"===this.type&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:t}=this;if(!e||!t||!this.renderer)return;const{rasterInfo:i}=this.raster,n=(0,R.ct)(i,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=n?.name,s=(0,A.$P)({...this.renderer.toJSON(),variableName:r});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(s))return;const o=this._rasterJobHandler.instance;o&&(t.rasterInfo=(0,A.m7)(i,r),t.rendererJSON=s,t.bind(),await o.updateSymbolizer(t),this._cachedRendererJson=s)}async applyRenderer(e,t){const i=e?.pixelBlock;if(!(null!=i&&i.pixels&&i.pixels.length>0))return null;let n;await this.updateRenderer();const r=this._rasterJobHandler.instance,s=this.bandIds??[];return n=r?await r.symbolize({...e,simpleStretchParams:t,bandIds:s}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:s}),n}getTileUrl(e,t,i){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${i}`:""}getCompatibleTileInfo(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!this.loaded||null==t)return null;if(i&&e.equals(this.spatialReference))return this.tileInfo;const n=(0,f.Vp)(e);return w.A.create({size:256,spatialReference:e,origin:n?{x:n.origin[0],y:n.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(i(this),s.requestAsImageElement){const i=this.getTileUrl(e,t,n);return(0,r.A)(i,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then((e=>e.data))}const{serviceRasterInfo:o}=this;if(null!=o.multidimensionalInfo&&null==(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition){const i=s.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,n,i),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,n,s)}async fetchPixels(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),i=Math.round(i),this.raster.fetchPixels(e,t,i,n))}async identify(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.load();const{raster:i,serviceRasterInfo:n}=this;if(null!=n?.multidimensionalInfo&&(!n.hasMultidimensionalTranspose||!((0,R.DY)(t.multidimensionalDefinition)||t.transposedVariableName||t.timeExtent))&&null==(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition)return{location:e,value:null};const r=this.multidimensionalSubset?.areaOfInterest;if(r&&!r.contains(e))throw new s.A("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return i.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,i=t?.[0]?.variableName;return e.variables.some((e=>e.name===i&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date((0,R.$E)(e)).toISOString()}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo?.multidimensionalInfo;return(0,R.z2)(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,R.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new v.A;return this._rasterJobHandler.connectionPromise=e.initialize().then((async()=>{i(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){i(this);const{raster:e}=this,t=(0,A.w6)(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"no";i(this);const{rasterInfo:t}=this.raster,n=(0,R.ct)(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=n?.name,s=(0,A.I8)({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=s?.bandIds??(0,A.ci)(t)),!this.renderer||"override"===e){const e=(0,A.Mm)(this.raster),i=s?.renderer??(0,A.PD)(t,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:e}),n=t.statistics,o=n&&n.length>0?n[0]:null,l=o?.max??0,a=o?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===i.type&&(l>1e24||a<-1e24)&&(i.dynamicRangeAdjustment=!0,i.customStatistics=null,"none"===i.stretchType&&(i.stretchType="min-max")),this.renderer=i}const l=(0,A.$P)({...this.renderer.toJSON(),variableName:r}),a=(0,A.m7)(t,r);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=a):this.symbolizer=new P.A({rendererJSON:l,rasterInfo:a});const c=this.symbolizer.bind();if(c.success){if("auto"===e){const{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type){const e=(0,A.PD)(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer("override")}else if("raster-stretch"===t.type){const e=this.bandIds?.length,i=t.customStatistics?.length;!t.dynamicRangeAdjustment&&i&&e&&i!==e&&this._configDefaultRenderer("override")}}}else o.A.getLogger(this).warn("imagery-tile-mixin",c.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const e=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&e&&this._set("rasterFunction",b.A.fromJSON(e)))}let e,t=this.raster,i=!1;"Function"===t.datasetFormat?(e=t.primaryRasters.rasters,t=e[0],i=!0):e=[t];const{rasterFunction:n}=this;if(n){const i={raster:t};e.length>1&&e.forEach((e=>i[e.url]=e));const r=(0,T.vt)(n.functionDefinition?.toJSON()??n.toJSON(),i),s=new I.A({rasterFunction:r});s.rasterJobHandler=this._rasterJobHandler.instance,await s.open(),this.raster=s}else this.raster=t,await t.open();if(this._cachedRendererJson=null,!i&&!n)return;const{bandIds:r}=this,{bandCount:s}=this.raster.rasterInfo,o=r?.length?r.some((e=>e>=s)):s>=3;r&&(o||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function i(e){if(!e.raster||!e.serviceRasterInfo)throw new s.A("imagery-tile","no raster")}return(0,n._)([(0,l.MZ)({clonable:!1})],t.prototype,"_cachedRendererJson",void 0),(0,n._)([(0,l.MZ)({clonable:!1})],t.prototype,"_cachedRasterFunctionJson",void 0),(0,n._)([(0,l.MZ)({clonable:!1})],t.prototype,"_compatibleFullExtent",void 0),(0,n._)([(0,l.MZ)({clonable:!1})],t.prototype,"_isConstructedFromFunctionRaster",void 0),(0,n._)([(0,l.MZ)({clonable:!1})],t.prototype,"_rasterJobHandler",void 0),(0,n._)([(0,l.MZ)({clonable:!1})],t.prototype,"_rasterFunctionUpdatePromise",void 0),(0,n._)([(0,l.MZ)({type:[a.jz],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],t.prototype,"bandIds",void 0),(0,n._)([(0,l.MZ)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),(0,n._)([(0,l.MZ)({json:{read:!1}})],t.prototype,"fullExtent",null),(0,n._)([(0,l.MZ)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,c.e)(_.SZ)],t.prototype,"interpolation",void 0),(0,n._)([(0,l.MZ)()],t.prototype,"ioConfig",void 0),(0,n._)([(0,l.MZ)({type:[y.A],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),(0,n._)([(0,l.MZ)({type:x.A,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),(0,n._)([(0,l.MZ)()],t.prototype,"raster",void 0),(0,n._)([(0,l.MZ)({type:b.A})],t.prototype,"rasterFunction",null),(0,n._)([(0,l.MZ)()],t.prototype,"serviceRasterInfo",void 0),(0,n._)([(0,l.MZ)()],t.prototype,"sourceJSON",void 0),(0,n._)([(0,l.MZ)({readOnly:!0,type:m.A,json:{read:!1}})],t.prototype,"spatialReference",void 0),(0,n._)([(0,l.MZ)({type:w.A})],t.prototype,"tileInfo",void 0),(0,n._)([(0,l.MZ)(g.OZ)],t.prototype,"url",null),(0,n._)([(0,l.MZ)()],t.prototype,"renderer",null),(0,n._)([(0,l.MZ)({types:C.uy,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:C.Gj,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],t.prototype,"internalRenderer",null),(0,n._)([(0,u.w)("internalRenderer")],t.prototype,"readRenderer",null),(0,n._)([(0,l.MZ)({clonable:!1})],t.prototype,"symbolizer",void 0),t=(0,n._)([(0,h.$)("esri.layers.mixins.ImageryTileMixin")],t),t}},34429:(e,t,i)=>{i.d(t,{QueueProcessor:()=>u});var n=i(30726),r=i(50346),s=i(59649),o=i(67993),l=i(52394),a=i(75540);class c{constructor(e,t){this.item=e,this.controller=t,this.promise=null}}class u{constructor(e){this._schedule=null,this._deferreds=new o.A,this._controllers=new o.A,this._processingItems=new o.A,this._pausedSignal=(0,a.v)(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new s.A(e.peeker),this.process=e.process}destroy(){this.clear(),this._schedule=(0,n.xt)(this._schedule)}get updating(){return this.running}get length(){return this._processingItems.size+this._queue.length}get running(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}abort(e){const t=this._controllers.get(e);t&&t.abort()}clear(){this._queue.clear();const e=[];this._controllers.forEach((t=>e.push(t))),this._controllers.clear(),e.forEach((e=>e.abort())),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach(((t,i)=>e(i)))}get(e){const t=this._deferreds.get(e);return t?t.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,t){const i=this.get(e);if(i)return i;const n=new AbortController;let s=null;t&&(s=(0,r.u7)(t,(()=>n.abort())));const o=()=>{l.remove(),null!=s&&s.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},l=(0,r.NY)(n.signal,(()=>{const t=this._processingItems.get(e);t&&t.controller.abort(),o(),a.reject((0,r.NK)())})),a=(0,r.Tw)();return this._deferreds.set(e,a),this._controllers.set(e,n),a.promise.then(o,o),this._queue.push(e),this._scheduleNext(),a.promise}last(){return this._queue.last()}lastPromise(){const e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){const e=this._queue.popLast();return e&&(this._deferreds.get(e)?.reject((0,r.NK)()),this._removeItem(e)),e}reset(){const e=Array.from(this._processingItems.values());this._processingItems.clear();for(const t of e)this._queue.push(t.item),t.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._pausedSignal.value||this._schedule||(this._schedule=(0,l._)((()=>{this._schedule=null,this._next()})))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(t))}_processError(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(t))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){if(null==e)return;let t;const i=new AbortController,n=new c(e,i);this._processingItems.set(e,n);try{t=this.process(e,i.signal)}catch(s){this._processError(n,s)}(0,r.$X)(t)?(n.promise=t,t.then((e=>this._processResult(n,e)),(e=>this._processError(n,e)))):this._processResult(n,t)}}},59187:(e,t,i)=>{i.d(t,{A:()=>m});var n,r=i(35143),s=i(42553),o=i(18288),l=i(46053),a=(i(81806),i(76460),i(47249),i(28379)),c=i(85842),u=i(17707),h=i(36693);let d=n=class extends s.A{static get allTime(){return f}static get empty(){return p}static fromArray(e){return new n({start:null!=e[0]?new Date(e[0]):e[0],end:null!=e[1]?new Date(e[1]):e[1]})}constructor(e){super(e),this.end=null,this.start=null}readEnd(e,t){return null!=t.end?new Date(t.end):null}writeEnd(e,t){t.end=e?.getTime()??null}get isAllTime(){return this.equals(n.allTime)}get isEmpty(){return this.equals(n.empty)}readStart(e,t){return null!=t.start?new Date(t.start):null}writeStart(e,t){t.start=e?.getTime()??null}clone(){return new n({end:this.end,start:this.start})}equals(e){if(!e)return!1;const t=this.start?.getTime()??this.start,i=this.end?.getTime()??this.end,n=e.start?.getTime()??e.start,r=e.end?.getTime()??e.end;return t===n&&i===r}expandTo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.qU;if(this.isEmpty||this.isAllTime)return this.clone();let i=this.start;i&&(i=(0,o.lL)(i,e,t));let r=this.end;if(r){const i=(0,o.lL)(r,e,t);r=r.getTime()===i.getTime()?i:(0,o.S1)(i,1,e,t)}return new n({start:i,end:r})}intersection(e){if(!e)return this.clone();if(this.isEmpty||e.isEmpty)return n.empty;if(this.isAllTime)return e.clone();if(e.isAllTime)return this.clone();const t=this.start?.getTime()??-1/0,i=this.end?.getTime()??1/0,r=e.start?.getTime()??-1/0,s=e.end?.getTime()??1/0;let o,l;return r>=t&&r<=i?o=r:t>=r&&t<=s&&(o=t),i>=r&&i<=s?l=i:s>=t&&s<=i&&(l=s),null==o||null==l||isNaN(o)||isNaN(l)?n.empty:new n({start:o===-1/0?null:new Date(o),end:l===1/0?null:new Date(l)})}offset(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:h.qU;if(this.isEmpty||this.isAllTime)return this.clone();const r=new n,{start:s,end:l}=this;return null!=s&&(r.start=(0,o.S1)(s,e,t,i)),null!=l&&(r.end=(0,o.S1)(l,e,t,i)),r}toArray(){return this.isEmpty?[void 0,void 0]:[this.start?.getTime()??null,this.end?.getTime()??null]}union(e){if(!e||e.isEmpty)return this.clone();if(this.isEmpty)return e.clone();if(this.isAllTime||e.isAllTime)return f.clone();const t=null!=this.start&&null!=e.start?new Date(Math.min(this.start.getTime(),e.start.getTime())):null,i=null!=this.end&&null!=e.end?new Date(Math.max(this.end.getTime(),e.end.getTime())):null;return new n({start:t,end:i})}};(0,r._)([(0,l.MZ)({type:Date,json:{write:{allowNull:!0}}})],d.prototype,"end",void 0),(0,r._)([(0,a.w)("end")],d.prototype,"readEnd",null),(0,r._)([(0,u.K)("end")],d.prototype,"writeEnd",null),(0,r._)([(0,l.MZ)({readOnly:!0,json:{read:!1}})],d.prototype,"isAllTime",null),(0,r._)([(0,l.MZ)({readOnly:!0,json:{read:!1}})],d.prototype,"isEmpty",null),(0,r._)([(0,l.MZ)({type:Date,json:{write:{allowNull:!0}}})],d.prototype,"start",void 0),(0,r._)([(0,a.w)("start")],d.prototype,"readStart",null),(0,r._)([(0,u.K)("start")],d.prototype,"writeStart",null),d=n=(0,r._)([(0,c.$)("esri.time.TimeExtent")],d);const m=d,f=new d,p=new d({start:void 0,end:void 0})},67993:(e,t,i)=>{i.d(t,{A:()=>s});var n=i(99486),r=i(99702);class s{constructor(e){this._observable=new r.I,this._map=new Map(e)}get size(){return(0,n.gc)(this._observable),this._map.size}clear(){this._map.size>0&&(this._map.clear(),this._observable.notify())}delete(e){const t=this._map.delete(e);return t&&this._observable.notify(),t}entries(){return(0,n.gc)(this._observable),this._map.entries()}forEach(e,t){(0,n.gc)(this._observable),this._map.forEach(((i,n)=>e.call(t,i,n,this)),t)}get(e){return(0,n.gc)(this._observable),this._map.get(e)}has(e){return(0,n.gc)(this._observable),this._map.has(e)}keys(){return(0,n.gc)(this._observable),this._map.keys()}set(e,t){return this._map.set(e,t),this._observable.notify(),this}values(){return(0,n.gc)(this._observable),this._map.values()}[Symbol.iterator](){return(0,n.gc)(this._observable),this._map[Symbol.iterator]()}[Symbol.dispose](){this._observable.destroy()}get[Symbol.toStringTag](){return this._map[Symbol.toStringTag]}}},75540:(e,t,i)=>{i.d(t,{v:()=>l});var n=i(53084),r=i(99486),s=i(99702);class o{constructor(e,t){this._observable=new s.I,this._value=e,this._equalityFunction=t}get value(){return(0,r.gc)(this._observable),this._value}set value(e){this._equalityFunction(e,this._value)||(this._value=e,this._observable.notify())}mutate(e){e(this._value),this._observable.notify()}}function l(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.gh;return new o(e,t)}},86769:(e,t,i)=>{function n(e,t){if(!e||!t)return[];let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=[];if(t){const s=n(e,i);for(let e=0;e<s.length;e++)n(s[e],t).forEach((e=>r.push(e)));return r}const s=e.getElementsByTagNameNS("*",i);if(!s||0===s.length)return[];for(let n=0;n<s.length;n++)r.push(s[n]||s.item(n));return r}function r(e,t){if(!e||!t)return null;let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const s=n(e,i);return s.length>0?t?r(s[0],t):s[0]:null}function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const i=t?r(e,t):e;let n;return i?(n=i.textContent||i.nodeValue,n?n.trim():null):null}function o(e,t){const i=n(e,t),r=[];let s;for(let n=0;n<i.length;n++)s=i[n].textContent||i[n].nodeValue,s&&(s=s.trim(),""!==s&&r.push(s));return r}function l(e){const t=s(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null);return t?.split(" ").map((e=>Number(e)))??[]}function a(e,t){return o(e,t).map((e=>Number(e)))}function c(e,t){const i=s(e,t);return Number(i)}function u(e,t){const i=e?.nodeName?.toLowerCase(),n=t.toLowerCase();return i.slice(i.lastIndexOf(":")+1)===n}function h(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}i.d(t,{Dy:()=>o,IC:()=>n,Ui:()=>a,V6:()=>r,g7:()=>u,mX:()=>s,pN:()=>l,v7:()=>c,vv:()=>h})}}]);
//# sourceMappingURL=7655.3e0f8893.chunk.js.map